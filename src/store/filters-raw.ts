/**
 * Filter Store - Raw Implementation
 * Handles Firestore Direct Access and Caching
 */

import { db } from '../core/firebase';
import {
    Unsubscribe,
    addDoc,
    collection,
    deleteDoc,
    doc,
    onSnapshot,
    query,
    serverTimestamp,
    updateDoc
} from "../core/firebase-sdk";
import { paths } from '../utils/paths';
import { withRetry } from '../utils/retry';
import { Filter } from './schema';
import { toast } from './ui/toast-store';

class FilterCache {
    private static instance: FilterCache;
    private cacheMap = new Map<string, Filter[]>();
    private listeners = new Map<string, Set<(filters: Filter[]) => void>>();
    private unsubscribes = new Map<string, Unsubscribe>();

    private constructor() { }

    public static getInstance(): FilterCache {
        if (!FilterCache.instance) {
            FilterCache.instance = new FilterCache();
        }
        return FilterCache.instance;
    }

    public getFilters(workspaceId: string): Filter[] {
        return this.cacheMap.get(workspaceId) || [];
    }

    public isInitialized(workspaceId: string): boolean {
        return this.cacheMap.has(workspaceId);
    }

    public setCache(workspaceId: string, filters: Filter[]) {
        this.cacheMap.set(workspaceId, filters);
        this.notify(workspaceId);
    }

    public clearCache(workspaceId?: string) {
        if (workspaceId) {
            this.cacheMap.delete(workspaceId);
            this.notify(workspaceId); // Notify empty? or just clear
        } else {
            this.cacheMap.clear();
        }
    }

    private notify(workspaceId: string) {
        const filters = this.getFilters(workspaceId);
        const workspaceListeners = this.listeners.get(workspaceId);
        if (workspaceListeners) {
            workspaceListeners.forEach(cb => cb([...filters]));
        }
    }

    public subscribe(userId: string | undefined, workspaceId: string, callback: (filters: Filter[]) => void): Unsubscribe {
        if (!userId || !workspaceId) {
            callback([]);
            return () => { };
        }

        // Register listener
        if (!this.listeners.has(workspaceId)) {
            this.listeners.set(workspaceId, new Set());
        }
        this.listeners.get(workspaceId)!.add(callback);

        // Initial Return (Optimistic)
        const cached = this.cacheMap.get(workspaceId);
        if (cached) {
            queueMicrotask(() => callback([...cached]));
        }

        // Start Firestore subscription if needed
        if (!this.unsubscribes.has(workspaceId)) {
            const path = paths.filters(userId, workspaceId);
            const q = query(collection(db, path));

            const unsub = onSnapshot(q, (snapshot) => {
                const filters = snapshot.docs.map(doc => ({
                    id: doc.id,
                    ...doc.data()
                })) as Filter[];

                this.cacheMap.set(workspaceId, filters);
                this.notify(workspaceId);

            }, (error) => {
                console.error("[Filters] Subscription error:", error);
                this.cacheMap.set(workspaceId, []);
                this.notify(workspaceId);
            });

            this.unsubscribes.set(workspaceId, unsub);
        }

        return () => {
            const workspaceListeners = this.listeners.get(workspaceId);
            if (workspaceListeners) {
                workspaceListeners.delete(callback);
            }
        };
    }
}

const cache = FilterCache.getInstance();

// --- Raw Exports ---

export function subscribeToFiltersRaw(userId: string, workspaceId: string, callback: (filters: Filter[]) => void): Unsubscribe {
    return cache.subscribe(userId, workspaceId, callback);
}

export function getFiltersRaw(workspaceId: string): Filter[] {
    return cache.getFilters(workspaceId);
}

export function isFiltersInitializedRaw(workspaceId: string): boolean {
    return cache.isInitialized(workspaceId);
}

export function clearFiltersCacheRaw(workspaceId?: string) {
    cache.clearCache(workspaceId);
}

export async function addFilterRaw(userId: string, workspaceId: string, filter: Omit<Filter, 'id' | 'createdAt'>) {
    const originalFilters = cache.getFilters(workspaceId);

    // Optimistic Update
    // We create a temp ID for optimistic update if needed, but since we use addDoc, ID is generated by server mostly.
    // Ideally we generate ID client side or wait. 
    // Here we simulate optimistic addition for better UX.
    const tempId = 'temp_' + Date.now();
    const tempFilter = { ...filter, id: tempId, createdAt: new Date() } as unknown as Filter;

    cache.setCache(workspaceId, [...originalFilters, tempFilter]);

    const path = paths.filters(userId, workspaceId);

    return withRetry(async () => {
        const docRef = await addDoc(collection(db, path), {
            ...filter,
            createdAt: serverTimestamp()
        });
        // Update cache with real ID if needed, but subscription will handle it shortly.
        return docRef.id;
    }, {
        onFinalFailure: () => {
            cache.setCache(workspaceId, originalFilters);
            toast.error('フィルタの作成に失敗しました');
        }
    });
}

export async function updateFilterRaw(userId: string, workspaceId: string, filterId: string, updates: Partial<Filter>) {
    const originalFilters = cache.getFilters(workspaceId);

    // Optimistic Update
    const newFilters = originalFilters.map(f => f.id === filterId ? { ...f, ...updates } : f);
    cache.setCache(workspaceId, newFilters);

    const path = paths.filters(userId, workspaceId);

    return withRetry(async () => {
        await updateDoc(doc(db, path, filterId), {
            ...updates,
            updatedAt: serverTimestamp()
        });
    }, {
        onFinalFailure: () => {
            cache.setCache(workspaceId, originalFilters);
            toast.error('フィルタの更新に失敗しました');
        }
    });
}

export async function deleteFilterRaw(userId: string, workspaceId: string, filterId: string) {
    const originalFilters = cache.getFilters(workspaceId);

    // Optimistic Update
    const newFilters = originalFilters.filter(f => f.id !== filterId);
    cache.setCache(workspaceId, newFilters);

    const path = paths.filters(userId, workspaceId);

    return withRetry(async () => {
        await deleteDoc(doc(db, path, filterId));
    }, {
        onFinalFailure: () => {
            cache.setCache(workspaceId, originalFilters);
            toast.error('フィルタの削除に失敗しました');
        }
    });
}
